import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as t,o as n}from"./app-DnLzMSw7.js";const a="/assets/image-1-DtX3rxKj.png",o="/assets/image-2-UXpnuB4R.png",l="/assets/image-D0KU-qhn.png",r={};function p(g,i){return n(),e("div",null,i[0]||(i[0]=[t('<h1 id="gmp面试题" tabindex="-1"><a class="header-anchor" href="#gmp面试题"><span>GMP面试题</span></a></h1><h2 id="_1-go语言的gmp模型是什么" tabindex="-1"><a class="header-anchor" href="#_1-go语言的gmp模型是什么"><span>1. Go语言的GMP模型是什么？</span></a></h2><p>GMP是Go运行时的核心调度模型</p><p><strong>GMP含义</strong>：G是goroutine协程；M是machine系统线程，真正干活的；P是processor，逻辑处理器，它是G和M之间的桥梁。它负责调度G</p><p>调度逻辑是这样的，M必须绑定P才能执行G。每个P维护一个自己的本地G队列（长度256），M从P的本地队列取G执行。当本地队列空时，M会按优先级从<strong>全局队列、网络轮询器、其他P队列</strong>中窃取goroutine，这是work-stealing机制。</p><p>就是这个模型让Go能在少量线程上调度海量goroutine，是Go高并发的基础。</p><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-什么是go-scheduler" tabindex="-1"><a class="header-anchor" href="#_2-什么是go-scheduler"><span>2. 什么是Go scheduler</span></a></h2><p>Go scheduler就是Go运行时的<strong>协程调度器</strong>，负责在系统线程上调度执行goroutine。它 是 Go runtime 的一部分，它内嵌在 Go 程序里，和 Go 程序一起运行。它的主要工作是决定哪个goroutine在哪个线程上运行，以及何时进行上下文切换。scheduler的核心是<code>schedule()</code>函数，它在无限循环中寻找可运行的goroutine。当找到后通过<code>execute()</code>函数切换到goroutine执行，goroutine主动让出或被抢占时再回到调度循环。</p><h2 id="_3-go语言在进行goroutine调度的时候-调度策略是怎样的" tabindex="-1"><a class="header-anchor" href="#_3-go语言在进行goroutine调度的时候-调度策略是怎样的"><span>3. Go语言在进行goroutine调度的时候，调度策略是怎样的？</span></a></h2><p>Go语言采用的是抢占式调度策略。Go 会启动一个线程，一直运行着“sysmon”函数，sysmon 运行在 M上，且不需要P。当 sysmon 发现 M 已运行同一个 G（Goroutine）10ms 以上时，它会将该 G 的内部参数 <code>preempt</code> 设置为 true，表示需要被抢占，让出CPU了。只是在Go 1.14之前和Go 1.14之后有所不同</p><p><strong>Go 1.14之前</strong>：调度策略是“协作式”抢占调度，这种调度方式主要是通过函数调用来实现的，在编译期，编译器会在几乎所有的函数调用的入口处，插入一小段检查代码。这段代码会检查当前goroutine是否已经被标记为需要被抢占。如果是，当 G 进行函数调用时，G 会检查自己的 <code>preempt</code> 标志，如果它为 true，则它将自己与 M 分离并推入goroutine的全局队列，抢占完成。但这种模式有个明显的缺陷：如果一个goroutine执行了一个不包含任何函数调用的<strong>超大循环</strong>，那么调度器的“抢占”标记就永远得不到检查，这个goroutine就会一直霸占着M，导致同一个P队列里的其他G全都没机会执行，造成<strong>调度延迟</strong>。</p><p><strong>Go 1.14之后</strong>：调度策略<strong>基于信号的异步抢占</strong>机制，sysmon 会检测到运行了 10ms 以上的 G（goroutine）。然后，sysmon 向运行 G 的 M发送信号（SIGURG）。Go 的信号处理程序会调用M上的一个叫作 gsignal 的 goroutine 来处理该信号，并使其检查该信号。gsignal 看到抢占信号，停止正在运行的 G。</p><h2 id="_4-发生调度的时机有哪些" tabindex="-1"><a class="header-anchor" href="#_4-发生调度的时机有哪些"><span>4. 发生调度的时机有哪些？</span></a></h2><ul><li><p>等待读取或写入未缓冲的通道</p></li><li><p>由于 time.Sleep() 而等待</p></li><li><p>等待互斥量释放</p></li><li><p>发生系统调用</p></li></ul><h2 id="_5-m寻找可运行g的过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_5-m寻找可运行g的过程是怎样的"><span>5. M寻找可运行G的过程是怎样的？</span></a></h2><p><strong>M会优先检查本地队列（LRQ）</strong>：从当前P的LRQ里<code>runqget</code>一个G。（无锁CAS），如果本地队列没有可运行G，<strong>再次检查全局队列（GRQ）</strong>去全局队列里<code>globrunqget</code>找。（需要加锁）；如果还没有，就<strong>检查网络轮询器（netpoll），</strong>就去<code>netpoll</code>里看看有没有因为网络IO就绪的G。（非阻塞模式），依然没有获取到可运行G，则会<strong>从别的P偷（steal work），这个偷的过程是</strong>随机找一个别的P，从它的LRQ里偷一半的G过来。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_6-gmp能不能去掉p层-会怎么样" tabindex="-1"><a class="header-anchor" href="#_6-gmp能不能去掉p层-会怎么样"><span>6. GMP能不能去掉P层？会怎么样？</span></a></h2><p>GMP中的P层理论上可以去掉，但会带来严重的性能问题。</p><p><strong>掉P的后果</strong>：如果直接变成GM模型，所有M都需要从<strong>全局队列</strong>中获取goroutine，这就需要全局锁保护。在高并发场景下，大量M争抢同一把锁会造成严重的<strong>锁竞争</strong>，CPU大部分时间都浪费在等锁上，调度效率急剧下降。</p><p><strong>P层的价值</strong>：P的存在实现了<strong>无锁的本地调度</strong>。每个P维护独立的本地队列，M绑定P后可以直接从本地队列取G执行，大部分情况下都不需要全局锁。只有本地队列空了才去偷取，这大大减少了锁竞争。</p><h2 id="_7-p和m在什么时候会被创建" tabindex="-1"><a class="header-anchor" href="#_7-p和m在什么时候会被创建"><span>7. P和M在什么时候会被创建？</span></a></h2><p><strong>P的创建时机</strong>：P在调度器初始化时<strong>一次性创建</strong>。在<code>schedinit()</code>函数中会调用<code>procresize()</code>，根据<code>GOMAXPROCS</code>值创建对应数量的P对象，存储在全局的<code>allp</code>数组中。之后P的数量基本固定，只有在调用<code>runtime.GOMAXPROCS()</code>动态调整时才会重新分配P。</p><p><strong>M的创建时机</strong>：M采用<strong>按需创建</strong>策略。初始只有m0存在，当出现以下情况时会创建新的M：</p><ul><li><p>所有现有M都在执行阻塞的系统调用，但还有可运行的goroutine需要执行</p></li><li><p>通过<code>startm()</code>函数发现没有空闲M可以绑定P执行goroutine</p></li><li><p>M的数量受<code>GOMAXTHREADS</code>限制，默认10000个</p></li></ul><p><strong>创建流程</strong>：新M通过<code>newm()</code>函数创建，它会调用<code>newosproc()</code>创建新的系统线程，并为这个M分配独立的g0。创建完成后，新M会进入<code>mstart()</code>开始调度循环。</p><h2 id="_8-m0是什么-有什么用" tabindex="-1"><a class="header-anchor" href="#_8-m0是什么-有什么用"><span>8. m0是什么，有什么用</span></a></h2><p>m0是在Go启动时创建的第一个M，m0对应程序启动时的主系统线程，它在Go程序的整个生命周期中都存在。与其他通过<code>runtime.newm()</code>动态创建的M不同，m0是在程序初始化阶段静态分配的，有专门的全局变量存储。</p><p>m0主要负责执行Go程序的<strong>启动流程</strong>，包括调度器初始化、内存管理器初始化、垃圾回收器设置等。它会创建并运行第一个用户goroutine来执行<code>main.main</code>函数。在程序运行期间，m0也参与正常的goroutine调度，和其他M没有本质区别。m0在程序退出时还负责处理清理工作，比如等待其他goroutine结束、执行defer函数等。</p><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_9-g0是一个怎样的协程-有什么用" tabindex="-1"><a class="header-anchor" href="#_9-g0是一个怎样的协程-有什么用"><span>9. g0是一个怎样的协程，有什么用？</span></a></h2><p>g0是一个特殊的goroutine，不是普通的用户协程，而是<strong>调度协程</strong>，每个M都有自己的g0。它使用系统线程的原始栈空间，而不是像普通goroutine那样使用可增长的分段栈。g0的栈大小通常是8KB，比普通goroutine的2KB初始栈要大。</p><p><strong>核心作用</strong>：g0专门负责<strong>执行调度逻辑</strong>，包括goroutine的创建、销毁、调度决策等。当M需要进行调度时，会从当前运行的用户goroutine切换到g0上执行<code>schedule()</code>函数。g0还负责处理垃圾回收、栈扫描、信号处理等运行时操作。</p><p><strong>运行机制</strong>：正常情况下M在用户goroutine上运行用户代码，当发生调度事件时（如goroutine阻塞、抢占、系统调用返回等），M会切换到g0执行调度器代码，选出下一个要运行的goroutine后再切换过去。</p><p><strong>为什么需要g0</strong>：因为调度器代码不能在普通goroutine的栈上执行，那样会有栈空间冲突和递归调度的问题。g0提供了一个独立的执行环境，确保调度器能安全稳定地工作。</p><h2 id="_10-g0栈和用户栈是如何进行切换的" tabindex="-1"><a class="header-anchor" href="#_10-g0栈和用户栈是如何进行切换的"><span>10. g0栈和用户栈是如何进行切换的？</span></a></h2><p>g0和用户goroutine之间的栈切换，本质是<strong>SP寄存器和栈指针的切换。</strong>当用户goroutine需要调度时，通过<code>mcall()</code>函数切换到g0。这个过程会保存当前用户goroutine的PC、SP等寄存器到其gobuf中，然后将SP指向g0的栈，PC指向传入的调度函数。调度完成后，通过<code>gogo()</code>函数从g0切换回用户goroutine，恢复其保存的寄存器状态。</p><p>切换逻辑在汇编文件中实现，比如<code>runtime·mcall</code>和<code>runtime·gogo</code>。这些函数直接操作CPU寄存器，确保切换的原子性和高效性。切换过程中会更新g.sched字段记录goroutine状态。</p><p><strong>分析：</strong></p><p>goroutine的结构如下：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">structG</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uintptr</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    stackguard</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;    </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 分段栈的可用空间下界</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uintptr</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    stackbase</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 分段栈的栈基址</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    Gobuf</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    sched</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;           </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//协程切换时，利用sched域来保存上下文</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uintptr</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    stack0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    FuncVal</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    fnstart</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// goroutine运行的函数void*    param;        // 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int16</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;          </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 状态    Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int64</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    goid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;            </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// goroutine的id号</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    G</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    schedlink</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    M</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;                  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// for debuggers, but offset not hard-coded</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    M</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    lockedm</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;            </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// G被锁定只能在这个m上运行</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uintptr</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    gopc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;          </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建这个goroutine的go表达式的pc...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,42)]))}const c=s(r,[["render",p],["__file","GMP面试题.html.vue"]]),k=JSON.parse('{"path":"/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/GMP%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"GMP面试题","lang":"zh-CN","frontmatter":{"tags":["Go","golang","GMP","面试题","GMP面试题"],"description":"GMP面试题 1. Go语言的GMP模型是什么？ GMP是Go运行时的核心调度模型 GMP含义：G是goroutine协程；M是machine系统线程，真正干活的；P是processor，逻辑处理器，它是G和M之间的桥梁。它负责调度G 调度逻辑是这样的，M必须绑定P才能执行G。每个P维护一个自己的本地G队列（长度256），M从P的本地队列取G执行。当本...","head":[["meta",{"property":"og:url","content":"https://xiucaistack.cn/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/GMP%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"秀才的进阶之路"}],["meta",{"property":"og:title","content":"GMP面试题"}],["meta",{"property":"og:description","content":"GMP面试题 1. Go语言的GMP模型是什么？ GMP是Go运行时的核心调度模型 GMP含义：G是goroutine协程；M是machine系统线程，真正干活的；P是processor，逻辑处理器，它是G和M之间的桥梁。它负责调度G 调度逻辑是这样的，M必须绑定P才能执行G。每个P维护一个自己的本地G队列（长度256），M从P的本地队列取G执行。当本..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-26T15:42:17.000Z"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:tag","content":"GMP"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:tag","content":"GMP面试题"}],["meta",{"property":"article:modified_time","content":"2025-06-26T15:42:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-26T15:42:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"秀才\\",\\"url\\":\\"https://github.com/Percygu\\"}]}"]]},"headers":[{"level":2,"title":"1. Go语言的GMP模型是什么？","slug":"_1-go语言的gmp模型是什么","link":"#_1-go语言的gmp模型是什么","children":[]},{"level":2,"title":"2. 什么是Go scheduler","slug":"_2-什么是go-scheduler","link":"#_2-什么是go-scheduler","children":[]},{"level":2,"title":"3. Go语言在进行goroutine调度的时候，调度策略是怎样的？","slug":"_3-go语言在进行goroutine调度的时候-调度策略是怎样的","link":"#_3-go语言在进行goroutine调度的时候-调度策略是怎样的","children":[]},{"level":2,"title":"4. 发生调度的时机有哪些？","slug":"_4-发生调度的时机有哪些","link":"#_4-发生调度的时机有哪些","children":[]},{"level":2,"title":"5. M寻找可运行G的过程是怎样的？","slug":"_5-m寻找可运行g的过程是怎样的","link":"#_5-m寻找可运行g的过程是怎样的","children":[]},{"level":2,"title":"6. GMP能不能去掉P层？会怎么样？","slug":"_6-gmp能不能去掉p层-会怎么样","link":"#_6-gmp能不能去掉p层-会怎么样","children":[]},{"level":2,"title":"7. P和M在什么时候会被创建？","slug":"_7-p和m在什么时候会被创建","link":"#_7-p和m在什么时候会被创建","children":[]},{"level":2,"title":"8. m0是什么，有什么用","slug":"_8-m0是什么-有什么用","link":"#_8-m0是什么-有什么用","children":[]},{"level":2,"title":"9. g0是一个怎样的协程，有什么用？","slug":"_9-g0是一个怎样的协程-有什么用","link":"#_9-g0是一个怎样的协程-有什么用","children":[]},{"level":2,"title":"10. g0栈和用户栈是如何进行切换的？","slug":"_10-g0栈和用户栈是如何进行切换的","link":"#_10-g0栈和用户栈是如何进行切换的","children":[]}],"git":{"createdTime":1750952537000,"updatedTime":1750952537000,"contributors":[{"name":"gupeng","username":"gupeng","email":"380059082@qq.com","commits":1,"url":"https://github.com/gupeng"}]},"readingTime":{"minutes":7.81,"words":2342},"filePathRelative":"Go语言系列/Go面试题库/GMP面试题.md","localizedDate":"2025年6月26日","autoDesc":true}');export{c as comp,k as data};
