import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-DJgFtDFQ.js";const l="/assets/image-2-EeZx6v-v.png",t="/assets/image-1-q5KUFZEy.png",h="/assets/image-BeYlZPWr.png",p={};function k(r,i){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="map面试题" tabindex="-1"><a class="header-anchor" href="#map面试题"><span>Map面试题</span></a></h1><h2 id="_1-go语言map的底层实现原理是怎样的" tabindex="-1"><a class="header-anchor" href="#_1-go语言map的底层实现原理是怎样的"><span>1. Go语言Map的底层实现原理是怎样的？</span></a></h2><p>map的就是一个hmap的结构。Go Map的底层实现是一个<strong>哈希表</strong>。它在运行时表现为一个指向<code>hmap</code>结构体的指针，<code>hmap</code>中记录了<strong>桶数组指针<code>buckets</code></strong>、<strong>溢出桶指针</strong>以及<strong>元素个数</strong>等字段。每个桶是一个<code>bmap</code>结构体，能存储<strong>8个键值对</strong>和<strong>8个<code>tophash</code></strong>，并有指向下一个<strong>溢出桶的指针<code>overflow</code></strong>。为了<strong>内存紧凑</strong>，<code>bmap</code>中采用的是先存8个键再存8个值的存储方式。</p><p><strong>分析：</strong><br> hmap结构定义：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// A header for a Go map.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> hmap</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   count</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     int</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // map中元素个数</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   flags</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     uint8</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 状态标志位，标记map的一些状态</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   B</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         uint8</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 桶数以2为底的对数，即B=log_2(len(buckets))，比如B=3，那么桶数为2^3=8</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   noverflow</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint16</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //溢出桶数量近似值</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   hash0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">     uint32</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 哈希种子</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   buckets</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pointer</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向buckets数组的指针</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   oldbuckets</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pointer</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 是一个指向buckets数组的指针，在扩容时，oldbuckets 指向老的buckets数组(大小为新buckets数组的一半)，非扩容时，oldbuckets 为空</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   nevacuate</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  uintptr</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 表示扩容进度的一个计数器，小于该值的桶已经完成迁移</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   extra</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">mapextra</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向mapextra 结构的指针，mapextra 存储map中的溢出桶</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>bmap结构如下：</p><figure><img src="'+t+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-go语言map的遍历是有序的还是无序的" tabindex="-1"><a class="header-anchor" href="#_2-go语言map的遍历是有序的还是无序的"><span>2. Go语言Map的遍历是有序的还是无序的？</span></a></h2><p>Go语言里Map的遍历是<strong>完全随机</strong>的，并没有固定的顺序。map每次遍历,都会从一个随机值序号的桶,在每个桶中，再从按照之前选定随机槽位开始遍历,所以是无序的。</p><h2 id="_3-go语言map的遍历为什么要设计成无序的" tabindex="-1"><a class="header-anchor" href="#_3-go语言map的遍历为什么要设计成无序的"><span>3. Go语言Map的遍历为什么要设计成无序的？</span></a></h2><p>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p><p>Go团队为了避免开发者写出依赖底层实现细节的脆弱代码，而<strong>有意为之</strong>的一个设计。通过在遍历时引入随机数，Go从根本上杜绝了程序员依赖特定遍历顺序的可能性，强制我们写出更健壮的代码。</p><h2 id="_4-map如何实现顺序读取" tabindex="-1"><a class="header-anchor" href="#_4-map如何实现顺序读取"><span>4. Map如何实现顺序读取？</span></a></h2><p>如果业务上确实需要有序遍历，最规范的做法就是将Map的键（Key）取出来放入一个切片（Slice）中，用<code>sort</code>包对切片进行排序，然后根据这个有序的切片去遍历Map。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">   &quot;fmt&quot;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">   &quot;sort&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   keyList</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   m</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">800</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">500</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   for</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> range</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      keyList</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">keyList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">   sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Ints</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">keyList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   for</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> _</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> range</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> keyList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      fmt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-go语言的map是否是并发安全的" tabindex="-1"><a class="header-anchor" href="#_5-go语言的map是否是并发安全的"><span>5. Go语言的Map是否是并发安全的？</span></a></h2><p>map 不是线程安全的。</p><p>在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志置位（等于1），则直接 panic。赋值和删除函数在检测完写标志是复位之后，先将写标志位置位，才会进行之后的操作。</p><p>检测写标志：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> h</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">flags</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">hashWriting</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">                throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;concurrent map writes&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设置写标志：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">flags</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> |=</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> hashWriting</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_6-map的key一定要是可比较的吗-为什么" tabindex="-1"><a class="header-anchor" href="#_6-map的key一定要是可比较的吗-为什么"><span>6. Map的Key一定要是可比较的吗？为什么？</span></a></h2><p>Map的Key必须要可比较。</p><p>首先，Map会对我们提供的Key进行哈希运算，得到一个哈希值。这个哈希值决定了这个键值对大概存储在哪个位置（也就是哪个“桶”里）。然而，不同的Key可能会产生相同的哈希值，这就是“哈希冲突”。当多个Key被定位到同一个“桶”里时，Map就没法只靠哈希值来区分它们了。此时，它必须在桶内进行逐个遍历，用我们传入的Key和桶里已有的每一个Key进行**相等（==）**比较。这样才能确保我们操作的是正确的键值对。</p><h2 id="_7-go语言map的扩容时机是怎样的" tabindex="-1"><a class="header-anchor" href="#_7-go语言map的扩容时机是怎样的"><span>7. Go语言Map的扩容时机是怎样的？</span></a></h2><p>向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容</p><ol><li><p>装载因子超过阈值，源码里定义的阈值是 6.5，这个时候会触发双倍扩容</p></li><li><p>overflow 的 bucket 数量过多：</p><ol><li><p>当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；</p></li><li><p>当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15</p></li></ol></li></ol><p>这两种情况下会触发双倍扩容</p><h2 id="_8-go语言map的扩容过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_8-go语言map的扩容过程是怎样的"><span>8. Go语言Map的扩容过程是怎样的？</span></a></h2><p>Go的扩容是<strong>渐进式（gradual</strong>）的。它不会在触发扩容时“stop the world”来一次性把所有数据搬迁到新空间，而是只分配新空间，然后在后续的每一次插入、修改或删除操作时，才会顺便搬迁一两个旧桶的数据。这种设计将庞大的扩容成本分摊到了多次操作中，极大地减少了服务的瞬间延迟（STW），保证了性能的平滑性。</p><p>如果是触发双倍扩容，会新建一个buckets数组，新的buckets数量大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。如果是等量扩容，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，这样节省空间，存取效率更高</p><h2 id="_9-可以对map的元素取地址吗" tabindex="-1"><a class="header-anchor" href="#_9-可以对map的元素取地址吗"><span>9. 可以对Map的元素取地址吗？</span></a></h2><p>无法对 map 的 key 或 value 进行取址。会发生编译报错，这样设计主要是因为map一旦发生扩容，key 和 value 的位置就会改变，之前保存的地址也就失效了。</p><p>示例：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;fmt&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        m</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        fmt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;qcrao&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会出现编译报错：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">go</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">14</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">cannot</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> take</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> the</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> address</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> of</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;qcrao&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_10-map-中删除一个-key-它的内存会释放么" tabindex="-1"><a class="header-anchor" href="#_10-map-中删除一个-key-它的内存会释放么"><span>10. Map 中删除一个 key，它的内存会释放么？</span></a></h2><p>不会，<code>delete</code>一个key，并不会立刻释放或收缩Map占用的内存。具体来说，<code>delete(m, key)</code> 这个操作，只是把key和value对应的内存块标记为“空闲”，让它们的内容可以被后续的垃圾回收（GC）处理掉。但是，Map底层为了存储这些键值对而分配的“桶”（buckets）数组，它的规模是不会缩小的。只有在置空这个map的时候，整个map的空间才会被垃圾回后释放</p><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_11-map可以边遍历边删除吗" tabindex="-1"><a class="header-anchor" href="#_11-map可以边遍历边删除吗"><span>11. Map可以边遍历边删除吗</span></a></h2><p>map 并不是一个线程安全的数据结构。如果多个线程边遍历，边删除，同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p><p>如果是发生在多个协程同时读写同一个 map 的情况下。 如果在同一个协程内边遍历边删除，并不会检测到同时读写，理论上是可以这样做的。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。这种情况下，可以通过加读写锁sync.RWMutex来保证</p>',45)]))}const o=s(p,[["render",k],["__file","Map面试题.html.vue"]]),c=JSON.parse('{"path":"/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Map%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Map面试题","lang":"zh-CN","frontmatter":{"tags":["Go","golang","map","面试题","map面试题"],"description":"Map面试题 1. Go语言Map的底层实现原理是怎样的？ map的就是一个hmap的结构。Go Map的底层实现是一个哈希表。它在运行时表现为一个指向hmap结构体的指针，hmap中记录了桶数组指针buckets、溢出桶指针以及元素个数等字段。每个桶是一个bmap结构体，能存储8个键值对和8个tophash，并有指向下一个溢出桶的指针overflow...","head":[["meta",{"property":"og:url","content":"https://xiucaistack.cn/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Map%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"秀才的进阶之路"}],["meta",{"property":"og:title","content":"Map面试题"}],["meta",{"property":"og:description","content":"Map面试题 1. Go语言Map的底层实现原理是怎样的？ map的就是一个hmap的结构。Go Map的底层实现是一个哈希表。它在运行时表现为一个指向hmap结构体的指针，hmap中记录了桶数组指针buckets、溢出桶指针以及元素个数等字段。每个桶是一个bmap结构体，能存储8个键值对和8个tophash，并有指向下一个溢出桶的指针overflow..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-26T15:42:17.000Z"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:tag","content":"map"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:tag","content":"map面试题"}],["meta",{"property":"article:modified_time","content":"2025-06-26T15:42:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Map面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-26T15:42:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"秀才\\",\\"url\\":\\"https://github.com/Percygu\\"}]}"]]},"headers":[{"level":2,"title":"1. Go语言Map的底层实现原理是怎样的？","slug":"_1-go语言map的底层实现原理是怎样的","link":"#_1-go语言map的底层实现原理是怎样的","children":[]},{"level":2,"title":"2. Go语言Map的遍历是有序的还是无序的？","slug":"_2-go语言map的遍历是有序的还是无序的","link":"#_2-go语言map的遍历是有序的还是无序的","children":[]},{"level":2,"title":"3. Go语言Map的遍历为什么要设计成无序的？","slug":"_3-go语言map的遍历为什么要设计成无序的","link":"#_3-go语言map的遍历为什么要设计成无序的","children":[]},{"level":2,"title":"4. Map如何实现顺序读取？","slug":"_4-map如何实现顺序读取","link":"#_4-map如何实现顺序读取","children":[]},{"level":2,"title":"5. Go语言的Map是否是并发安全的？","slug":"_5-go语言的map是否是并发安全的","link":"#_5-go语言的map是否是并发安全的","children":[]},{"level":2,"title":"6. Map的Key一定要是可比较的吗？为什么？","slug":"_6-map的key一定要是可比较的吗-为什么","link":"#_6-map的key一定要是可比较的吗-为什么","children":[]},{"level":2,"title":"7. Go语言Map的扩容时机是怎样的？","slug":"_7-go语言map的扩容时机是怎样的","link":"#_7-go语言map的扩容时机是怎样的","children":[]},{"level":2,"title":"8. Go语言Map的扩容过程是怎样的？","slug":"_8-go语言map的扩容过程是怎样的","link":"#_8-go语言map的扩容过程是怎样的","children":[]},{"level":2,"title":"9. 可以对Map的元素取地址吗？","slug":"_9-可以对map的元素取地址吗","link":"#_9-可以对map的元素取地址吗","children":[]},{"level":2,"title":"10. Map 中删除一个 key，它的内存会释放么？","slug":"_10-map-中删除一个-key-它的内存会释放么","link":"#_10-map-中删除一个-key-它的内存会释放么","children":[]},{"level":2,"title":"11. Map可以边遍历边删除吗","slug":"_11-map可以边遍历边删除吗","link":"#_11-map可以边遍历边删除吗","children":[]}],"git":{"createdTime":1750952537000,"updatedTime":1750952537000,"contributors":[{"name":"gupeng","username":"gupeng","email":"380059082@qq.com","commits":1,"url":"https://github.com/gupeng"}]},"readingTime":{"minutes":6.6,"words":1980},"filePathRelative":"Go语言系列/Go面试题库/Map面试题.md","localizedDate":"2025年6月26日","autoDesc":true}');export{o as comp,c as data};
