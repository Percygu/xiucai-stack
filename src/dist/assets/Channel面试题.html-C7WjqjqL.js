import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-DJgFtDFQ.js";const e="/assets/image-DLovTo1a.png",t="/assets/image-1-C1Nijp-i.png",h="/assets/image-3-t0oGwxrc.png",k="/assets/image-2-B9F68KY1.png",p={};function d(r,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="channel面试题" tabindex="-1"><a class="header-anchor" href="#channel面试题"><span>Channel面试题</span></a></h1><h2 id="_1-什么是csp" tabindex="-1"><a class="header-anchor" href="#_1-什么是csp"><span>1. 什么是CSP？</span></a></h2><p>CSP（Communicating Sequential Processes，通信顺序进程）并发编程模型，它的核心思想是：通过通信共享内存，而不是通过共享内存来通信。Go 语言的Goroutine 和 Channel机制，就是 CSP 的经典实现，具有以下特点：</p><ol><li><p>避免共享内存：协程（Goroutine）不直接修改变量，而是通过 Channel 通信</p></li><li><p>天然同步：Channel 的发送/接收自带同步机制，无需手动加锁</p></li><li><p>易于组合：Channel 可以嵌套使用，构建复杂并发模式（如管道、超时控制）</p></li></ol><h2 id="_2-channel的底层实现原理是怎样的" tabindex="-1"><a class="header-anchor" href="#_2-channel的底层实现原理是怎样的"><span>2. Channel的底层实现原理是怎样的？</span></a></h2><p>Channel的底层是一个名为<code>hchan</code>的结构体，核心包含几个关键组件：</p><p><strong>环形缓冲区：</strong>有缓冲channel内部维护一个固定大小的环形队列，用<code>buf</code>指针指向缓冲区，<code>sendx</code>和<code>recvx</code>分别记录发送和接收的位置索引。这样设计能高效利用内存，避免数据搬移。</p><p><strong>两个等待队列<code>sendq和recvq</code>：</strong>用来管理阻塞的goroutine。<code>sendq</code>存储因channel满而阻塞的发送者，<code>recvq</code>存储因channel空而阻塞的接收者。这些队列用双向链表实现，当条件满足时会唤醒对应的goroutine。</p><p><strong>互斥锁：</strong><code>hchan</code>内部有个mutex，所有的发送、接收操作都需要先获取锁，用来保证并发安全。虽然看起来可能影响性能，但Go的调度器做了优化，大多数情况下锁竞争并不激烈。</p><p>分析：</p><p>hchan定义如下：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> hchan</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // chan 里元素数量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        qcount</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   uint</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // chan 底层循环数组的长度</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        dataqsiz</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 指向底层循环数组的指针</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 只针对有缓冲的 channel</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        buf</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">      unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pointer</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // chan 中元素大小</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        elemsize</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint16</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // chan 是否被关闭的标志</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        closed</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   uint32</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // chan 中元素类型</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        elemtype</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_type</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // element type</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 已发送元素在循环数组中的索引</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        sendx</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uint</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // send index</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 已接收元素在循环数组中的索引</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        recvx</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uint</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // receive index</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 等待接收的 goroutine 队列</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        recvq</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    waitq</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // list of recv waiters</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 等待发送的 goroutine 队列</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        sendq</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    waitq</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // list of send waiters</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 保护 hchan 中所有字段</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        lock</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> mutex</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_3-向channel发送数据的过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_3-向channel发送数据的过程是怎样的"><span>3. 向channel发送数据的过程是怎样的？</span></a></h2><p>向channel发送数据的整个过程都会在mutex保护下进行，保证并发安全。会经历几个关键步骤：</p><ol><li><p><strong>首先是检查是否有等待的接收者</strong>。如果<code>recvq</code>队列不为空，说明有goroutine在等待接收数据，这时会直接把数据传递给等待的接收者，跳过缓冲区，这是最高效的路径。同时会唤醒对应的goroutine继续执行。</p></li><li><p><strong>如果没有等待接收者，就尝试写入缓冲区</strong>。检查缓冲区是否还有空间，如果<code>qcount &lt; dataqsiz</code>，就把数据复制到<code>buf[sendx]</code>位置，然后更新<code>sendx</code>索引和<code>qcount</code>计数。这是无缓冲或缓冲区未满时的正常流径。</p></li><li><p><strong>当缓冲区满了就需要阻塞等待</strong>。创建一个<code>sudog</code>结构体包装当前goroutine和要发送的数据，加入到<code>sendq</code>等待队列中，然后调用<code>gopark</code>让当前goroutine进入阻塞状态，让出CPU给其他goroutine。</p></li></ol><p><strong>被唤醒后继续执行</strong>。当有接收者从channel读取数据后，会从<code>sendq</code>中唤醒一个等待的发送者，被唤醒的goroutine会完成数据发送并继续执行。</p><p><strong>还有个特殊情况是向已关闭的channel发送数据会直接panic</strong>。这是Go语言的设计原则，防止向已关闭的通道写入数据。</p><p><strong>分析：</strong></p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;fmt&quot;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;time&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> goroutineA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    val</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">a</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    fmt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;goroutine A received data: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> goroutineB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    val</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">b</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    fmt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;goroutine B received data: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    ch</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    go</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> goroutineA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    go</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> goroutineB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    ch</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    time</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">time</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    ch1</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{})</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在第 17 行，主协程向 ch 发送了一个元素 3，来看下接下来会发生什么。</p><p>sender 发现 ch 的 recvq 里有 receiver 在等待着接收，就会出队一个 sudog，把 recvq 里 first 指针的 sudo “推举”出来了，并将其加入到 P 的可运行 goroutine 队列中。然后，sender 把发送元素拷贝到 sudog 的 elem 地址处，最后会调用 goready 将 G1 唤醒，状态变为 runnable。</p><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当调度器光顾 G1 时，将 G1 变成 running 状态，执行 goroutineA 接下来的代码。G 表示其他可能有的 goroutine。</p><p>这里其实涉及到一个协程写另一个协程栈的操作。有两个 receiver 在 channel 的一边虎视眈眈地等着，这时 channel 另一边来了一个 sender 准备向 channel 发送数据，为了高效，用不着通过 channel 的 buf “中转”一次，直接从源地址把数据 copy 到目的地址就可以了，效率高啊！</p><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图是一个示意图，<code>3</code> 会被拷贝到 G1 栈上的某个位置，也就是 val 的地址处，保存在 elem 字段。</p><h2 id="_4-从channel读取数据的过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_4-从channel读取数据的过程是怎样的"><span>4. 从Channel读取数据的过程是怎样的？</span></a></h2><p>从channel读取数据也有几个关键步骤：</p><ol><li><p><strong>首先检查是否有等待的发送者</strong>。如果<code>sendq</code>队列不为空，说明有goroutine在等待发送数据。对于无缓冲channel，会直接从发送者那里接收数据；对于有缓冲channel，会先从缓冲区取数据，然后把等待发送者的数据放入缓冲区，这样保持FIFO顺序。</p></li><li><p><strong>如果没有等待发送者，尝试从缓冲区读取</strong>。检查<code>qcount &gt; 0</code>，如果缓冲区有数据，就从<code>buf[recvx]</code>位置取出数据，然后更新<code>recvx</code>索引和<code>qcount</code>计数。这是缓冲区有数据时的正常路径。</p></li></ol><p><strong>缓冲区为空时需要阻塞等待</strong>。创建<code>sudog</code>结构体包装当前goroutine，加入到<code>recvq</code>等待队列，调用<code>gopark</code>进入阻塞状态。当有发送者写入数据时会被唤醒继续执行。</p><p><strong>从已关闭channel读取有特殊处理</strong>。如果channel已关闭且缓冲区为空，会返回零值和false标志；如果缓冲区还有数据，可以正常读取直到清空。这就是为什么<code>v, ok := &lt;-ch</code>中的ok能判断channel状态的原因。</p><h2 id="_5-从一个已关闭channel仍能读出数据吗" tabindex="-1"><a class="header-anchor" href="#_5-从一个已关闭channel仍能读出数据吗"><span>5. 从一个已关闭Channel仍能读出数据吗？</span></a></h2><p>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p><p><strong>示例：</strong></p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        ch</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">chan</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        ch</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 18</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ok</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ch</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ok</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">                fmt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;received: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ok</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ch</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ok</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">                fmt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;channel closed, data invalid.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序输出：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">received</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:  </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">18</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">channel</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> closed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> invalid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p><h2 id="_6-channel在什么情况下会引起内存泄漏" tabindex="-1"><a class="header-anchor" href="#_6-channel在什么情况下会引起内存泄漏"><span>6. Channel在什么情况下会引起内存泄漏？</span></a></h2><p>Channel引起内存泄漏最常见的是引起goroutine泄漏从而导致的间接内存泄漏，当goroutine阻塞在channel操作上永远无法退出时，goroutine本身和它引用的所有变量都无法被GC回收。比如一个goroutine在等待接收数据，但发送者已经退出了，这个接收者就会永远阻塞下去。或者<strong>select语句使用不当，</strong>在没有default分支的select中，如果所有case都无法执行，goroutine会永远阻塞。出现内存泄漏</p><h2 id="_7-关闭channel会产生异常吗" tabindex="-1"><a class="header-anchor" href="#_7-关闭channel会产生异常吗"><span>7. 关闭Channel会产生异常吗？</span></a></h2><p>试图重复关闭一个channel、，关闭一个nil值的channel、关闭一个只有接收方向的channel都将导致panic异常。</p><h2 id="_8-往一个关闭的channel写入数据会发生什么" tabindex="-1"><a class="header-anchor" href="#_8-往一个关闭的channel写入数据会发生什么"><span>8. 往一个关闭的Channel写入数据会发生什么？</span></a></h2><p>往已关闭的channel写入数据会直接panic。</p><p>向已关闭的channel发送数据时，runtime会检测到channel的<code>closed</code>标志位已经设置，立即抛出&quot;send on closed channel&quot;的panic。这个检查发生在发送操作的最开始阶段，甚至在获取mutex锁之前就会进行判断，所以不会有任何数据写入的尝试，直接就panic了。</p><h2 id="_9-什么是select" tabindex="-1"><a class="header-anchor" href="#_9-什么是select"><span>9. 什么是select？</span></a></h2><p>select是Go语言专门为channel操作设计的多路复用控制结构，类似于网络编程中的select系统调用。</p><p>核心作用是同时监听多个channel操作。当有多个channel都可能有数据收发时，select能够选择其中一个可执行的case进行操作，而不是按顺序逐个尝试。比如同时监听数据输入、超时信号、取消信号等。</p><h2 id="_10-select的执行机制是怎样的" tabindex="-1"><a class="header-anchor" href="#_10-select的执行机制是怎样的"><span>10. select的执行机制是怎样的？</span></a></h2><p>select的执行机制是随机选择。如果多个case同时满足条件，Go会随机选择一个执行，这避免了饥饿问题。如果没有case能执行就会执行default，如果没有default，当前goroutine会阻塞等待。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">case</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ch1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 处理ch1的数据</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">case</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ch2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 向ch2发送数据  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">case</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;-</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">timeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 超时处理</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 所有channel都不可用时执行</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_11-select的实现原理是怎样的" tabindex="-1"><a class="header-anchor" href="#_11-select的实现原理是怎样的"><span>11. select的实现原理是怎样的？</span></a></h2><p>Go语言实现<code>select</code>时，定义了一个数据结构scase表示每个<code>case</code>语句(包含<code>default</code>)。scase结构包含channel指针、操作类型等信息。select操作的整个过程通过selectgo函数在runtime层面实现。</p><p>Go运行时会将所有case进行<strong>随机排序</strong>，这是为了避免饥饿问题。然后执行<strong>两轮扫描策略</strong>：<strong>第一轮</strong>直接检查每个channel是否可读写，如果找到就绪的立即执行；如果都没就绪，第二轮就把当前goroutine加入到所有channel的发送或接收队列中，然后调用gopark进入睡眠状态，使<strong>当前goroutine</strong>让出CPU。</p><p>当某个channel变为可操作时，调度器会唤醒对应的goroutine，此时需要从其他channel的等待队列中清理掉这个goroutine，然后执行对应的case分支。</p><p>其核心原理是：case随机化 + 双重循环检测</p><p><strong>分析：</strong></p><p>scase结构定义：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> scase</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    c</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    *</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">hchan</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // channel指针</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    elem</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pointer</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 数据元素指针，用于存放发送/接收的数据</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    kind</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint16</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // case类型：caseNil、caseRecv、caseSend、caseDefault</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    pc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   uintptr</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 程序计数器，用于调试</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    releasetime</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int64</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 释放时间，用于竞态检测</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在默认的情况下，select 语句会在编译阶段经过如下过程的处理：</p><ol><li><p>将所有的 <code>case</code> 转换成包含<code> Channel </code>以及类型等信息的 scase 结构体；</p></li><li><p>调用运行时函数 <code>selectgo </code>获取被选择的<code>scase</code> 结构体索引，如果当前的<code> scase </code>是一个接收数据的操作，还会返回一个指示当前<code>case</code> 是否是接收的布尔值；</p></li><li><p>通过<code> for </code>循环生成一组<code> if </code>语句，在语句中判断自己是不是被选中的 <code>case</code>。</p></li></ol>',63)]))}const o=s(p,[["render",d],["__file","Channel面试题.html.vue"]]),A=JSON.parse('{"path":"/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Channel%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Channel面试题","lang":"zh-CN","frontmatter":{"tags":["Go","golang","channel","面试题","channel面试题"],"description":"Channel面试题 1. 什么是CSP？ CSP（Communicating Sequential Processes，通信顺序进程）并发编程模型，它的核心思想是：通过通信共享内存，而不是通过共享内存来通信。Go 语言的Goroutine 和 Channel机制，就是 CSP 的经典实现，具有以下特点： 避免共享内存：协程（Goroutine）不直接...","head":[["meta",{"property":"og:url","content":"https://xiucaistack.cn/Go%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Channel%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"秀才的进阶之路"}],["meta",{"property":"og:title","content":"Channel面试题"}],["meta",{"property":"og:description","content":"Channel面试题 1. 什么是CSP？ CSP（Communicating Sequential Processes，通信顺序进程）并发编程模型，它的核心思想是：通过通信共享内存，而不是通过共享内存来通信。Go 语言的Goroutine 和 Channel机制，就是 CSP 的经典实现，具有以下特点： 避免共享内存：协程（Goroutine）不直接..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-26T15:42:17.000Z"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:tag","content":"channel"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:tag","content":"channel面试题"}],["meta",{"property":"article:modified_time","content":"2025-06-26T15:42:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Channel面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-26T15:42:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"秀才\\",\\"url\\":\\"https://github.com/Percygu\\"}]}"]]},"headers":[{"level":2,"title":"1. 什么是CSP？","slug":"_1-什么是csp","link":"#_1-什么是csp","children":[]},{"level":2,"title":"2. Channel的底层实现原理是怎样的？","slug":"_2-channel的底层实现原理是怎样的","link":"#_2-channel的底层实现原理是怎样的","children":[]},{"level":2,"title":"3. 向channel发送数据的过程是怎样的？","slug":"_3-向channel发送数据的过程是怎样的","link":"#_3-向channel发送数据的过程是怎样的","children":[]},{"level":2,"title":"4. 从Channel读取数据的过程是怎样的？","slug":"_4-从channel读取数据的过程是怎样的","link":"#_4-从channel读取数据的过程是怎样的","children":[]},{"level":2,"title":"5. 从一个已关闭Channel仍能读出数据吗？","slug":"_5-从一个已关闭channel仍能读出数据吗","link":"#_5-从一个已关闭channel仍能读出数据吗","children":[]},{"level":2,"title":"6. Channel在什么情况下会引起内存泄漏？","slug":"_6-channel在什么情况下会引起内存泄漏","link":"#_6-channel在什么情况下会引起内存泄漏","children":[]},{"level":2,"title":"7. 关闭Channel会产生异常吗？","slug":"_7-关闭channel会产生异常吗","link":"#_7-关闭channel会产生异常吗","children":[]},{"level":2,"title":"8. 往一个关闭的Channel写入数据会发生什么？","slug":"_8-往一个关闭的channel写入数据会发生什么","link":"#_8-往一个关闭的channel写入数据会发生什么","children":[]},{"level":2,"title":"9. 什么是select？","slug":"_9-什么是select","link":"#_9-什么是select","children":[]},{"level":2,"title":"10. select的执行机制是怎样的？","slug":"_10-select的执行机制是怎样的","link":"#_10-select的执行机制是怎样的","children":[]},{"level":2,"title":"11. select的实现原理是怎样的？","slug":"_11-select的实现原理是怎样的","link":"#_11-select的实现原理是怎样的","children":[]}],"git":{"createdTime":1750952537000,"updatedTime":1750952537000,"contributors":[{"name":"gupeng","username":"gupeng","email":"380059082@qq.com","commits":1,"url":"https://github.com/gupeng"}]},"readingTime":{"minutes":9.39,"words":2817},"filePathRelative":"Go语言系列/Go面试题库/Channel面试题.md","localizedDate":"2025年6月26日","autoDesc":true}');export{o as comp,A as data};
