---
title: 只会 Redis？高并发下你的缓存架构怎么设计到极致？
tags: 
  - 场景题
  - 面试题
  - 缓存设计
  - 缓存架构
  - 架构设计
---

在后端架构设计的领域里，**“高性能”**&#x4E00;直是我们的终极追求目标。而在通往高性能的道路上，缓存无疑是那块最关键的基石。在之前的微服务架构探讨中，我们常说面试中最好用的两个“杀手锏”就是高可用方案和高性能方案。而在高性能方案的构建中，缓存的设计是绝对绕不过去的坎。

然而，我们很多人在面试，或者是在实际工作中做方案设计时，有一个普遍现象：大家对于缓存的理解往往停留在比较简单的阶段。最典型的回答莫过&#x4E8E;**“加一层 Redis”**。确实，引入 Redis 确实能显著提升性能，但在如今的技术环境下，Redis 的基本使用已经成为入行两三个月的新人都能熟练掌握的技能。如果在架构设计或面试中，仅仅拿出“我用了 Redis”这样的方案，是很难体现出你的技术深度和架构能力的。

今天，秀才就结合多年的实战经验和一些具体的业务场景，和你深入探讨几个**不那么常规**，但极具实战价值的缓存设计方案。这些方案不仅能帮你解决实际的性能瓶颈，更是你在面试中脱颖而出的利器。

## **1. 面试准备**

在深入具体方案之前，我们需要先纠正一个观念。当你谈论缓存时，千万不要干巴巴地只罗列技术点。你的最佳策略是将缓存方案作为提升整个系统性能的关键一环来阐述。

一个优秀的缓存方案设计，应该围绕以下几个核心维度展开：

1. **设计初衷**：为什么标准方案（仅 Redis）满足不了需求？

2. **命中率保障**：你是如何保证缓存能被命中的？

3. **一致性取舍**：引入缓存势必带来一致性问题，你是如何解决，或者如何做权衡的？

4. **量化指标**：这一套组合拳打下来，RT（响应时间）降低了多少？QPS 提升了多少？

5. **差异化竞争**：这个方案相比业界通用的“Redis + 数据库”模式，其独特之处在哪里？

尤其是最后一点，是体现你架构差异化竞争力的关键。常规方案面试官见得太多了，唯有结合具体业务特征的“出奇制胜”，才能给人留下深刻印象。

## **2. 一致性哈希+本地缓存**

我们先来看一个经典的组合拳方案：**一致性哈希 + 本地缓存 + Redis 缓存**。大家对“本地缓存 + Redis”的二级缓存模式想必并不陌生。但是，这种常规组合在面对极致性能要求时，往往显得有些力不从心。接下来秀才就分享一个我遇到过的真实案例。

当时我们组负责一个**商品详情页的核心价格接口**，性能指标要求极其苛刻，必须在毫秒级完成响应。起初，我们仅使用了 Redis 缓存，性能虽然达标，但随着大促期间并发量的激增，网络 IO 和 Redis 自身的序列化/反序列化开销逐渐成为了不可忽视的瓶颈。为了进一步压榨性能，引入进程内的本地缓存（如 Caffeine 或 Guava Cache）势在必行。

但是，单纯引入本地缓存会面临两个严重问题：

1. **内存浪费**：在集群模式下，由于负载均衡的随机性（如轮询），同一个热门商品（比如 ID 为 1001 的手机）的请求可能被分发到集群中的任意一台机器。这意味着 50 台机器的内存里都要缓存一份这个手机的数据，造成极大的资源浪费。

2. **命中率低下**：由于请求分散，本地缓存的命中率会非常低。用户 A 的请求上次落到机器 1 暖热了缓存，下次请求落到机器 2，又得重新查 Redis 或数据库，本地缓存难以发挥“极速”的优势。

为了解决这个痛点，我们在客户端（Client）或网关侧引入了**一致性哈希负载均衡算法**。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-1.png>)

如上图所示，这个方案的精髓在于流量调度：

1. **流量定向**：客户端通过一致性哈希算法，确保针对同一个业务 Key（例如 `product_id`）的请求，总是被路由到后端的同一台服务节点上。

2. **多级读取**：服务端收到请求后，先查本地缓存。由于请求被“钉”在了特定机器上，热点数据的本地缓存命中率得到了极大的保障。

3. **逐级回源**：只有在本地缓存未命中时，才去查 Redis，最后才是数据库。

4. **回写策略**：数据获取成功后，优先回写本地缓存，再异步或同步更新 Redis。

**实战效果与细节：** 经过这次改造，我们的接口性能提升了整整 **40%**。一致性哈希不仅解决了本地缓存命中率低的问题，还大幅减少了服务器间的冗余缓存数据。

> **注意点（面试加分项）：** 在面试时，你要主动谈到**节点变动**带来的风险。当服务节点扩容或缩容时，一致性哈希环会发生漂移，导致一部分 Key 对应的请求路由到了新机器，此时本地缓存会失效，瞬间产生回源压力。你需要评估这个瞬时冲击，并准备好相应的预案（比如哈希环的虚拟节点优化）。

## **3. 本地缓存兜底**

接下来我们聊聊**高可用**。在常规思维中，本地缓存是 Redis 的前置，是为了更快。但在某些极端场景下，本地缓存可以作为 Redis 的“备胎”，用于保命。

通常我们为了防止 Redis 挂掉，可能会搭建 Redis 集群或者准备备用的 Redis 实例。但实际上，应用服务器自身的内存也可以作为一种极佳的容错资源。这个方案的核心思想是：**正常情况下，请求只走 Redis；只有当 Redis 崩溃时，才启用本地缓存。**

我们看下面这张时序图，它清晰地描述了**Redis 崩溃前后**的切换逻辑：

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-2.png>)

**正常状态（Normal State）：**

* 客户端发起查询，服务端直接请求 Redis。

* 如果 Redis 没数据则查库并回写 Redis。

* **关键点**：此时，本地缓存是处于“休眠”状态的，或者仅仅作为极低频的备份，不参与核心读写链路。这样做的目的是为了避免维护复杂的双重缓存一致性。

**降级状态（Degraded State）：** 一旦监控系统检测到 Redis 崩溃，或者因为网络抖动导致连接长时间超时，系统会自动触发**降级开关**，查询逻辑发生翻转：

1. **优先查本地**：请求不再发往 Redis，而是优先查询本地缓存。

2. **兜底查库**：如果本地缓存没有，则去查数据库。

3. **回写本地**：将数据库查询结果回写到本地缓存中。

这个方案听起来似乎“反其道而行之”，因为通常我们是先查本地再查 Redis。但在这个场景下，本地缓存的作用是**保护数据库**。想象一下，当 Redis 突然不可用，成千上万的 QPS 瞬间击穿到数据库，数据库必死无疑。而启用本地缓存，虽然可能会面临数据时效性的问题（数据可能是旧的），但它能挡住绝大部分流量，保住数据库，让系统“活下来”。

**复原机制（Recovery）：** 还有一个关键点是**怎么切回来**。当后台监控发现 Redis 恢复服务后，千万不能立刻将所有流量切回 Redis，因为此时 Redis 可能是空的（冷启动）。正确的做法是：

* **灰度切流**：逐步将流量转发回 Redis。

* **预热**：或者在切流前，先异步地将热点数据刷入 Redis。

## **4. 请求级别缓存**

有时候，性能的损耗并非来自外部 IO，而是源于我们代码结构的“过度解耦”和模块化。在微服务或模块化设计中，我们强调边界。比如一个**电商下单流程**，可能涉及**订单模块**、**支付模块**和**库存模块**。这三个模块封装得很好，都需要根据 `user_id` 去获取用户信息（比如判断用户等级、收货地址等）。

**优化前的问题：**

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-3.png>)

如果没有特殊处理，如上图所示：

* 订单模块调用一次用户服务（或查库）。

* 支付模块又调用一次。

* 库存模块可能还要调一次。

在一个请求链路中，同一份数据被重复查询了三次。虽然单次查询不慢，但累积起来就是资源浪费，也增加了延迟。

**优化后的方案：**

这时，我们可以引入**请求级别缓存（Request-Scope Cache）**。它的生命周期非常短，仅存在于当前 HTTP 请求的处理过程中。当请求结束并返回响应时，缓存也就随之销毁。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-4.png>)

看上图的改进流程：

1. **构建上下文**：当请求进入时，我们可以利用 Java 中的 `Request-Scope Bean`（Spring 支持）或者 Go 语言中的 `context` 来存储这份临时数据。

2. **一次查询，多次使用**：当订单模块第一次查询用户信息后，将结果放入这个请求上下文的缓存中。

3. **后续复用**：后续支付模块再需要用户信息时，直接从上下文中读取即可。

**方案优势：** 这种方案最大的优势在于**几乎不需要考虑数据一致性**。因为缓存的生命周期仅有几百毫秒，在这期间数据发生变更且影响业务的概率微乎其微。这是一种极低成本但收益明显的代码级优化。

## **5. 会话级别缓存**

如果我们把缓存的生命周期稍微拉长一点，就变成了**会话级别缓存**。这非常类似于 Web 开发中传统的 Session。只要用户没有退出登录，或者会话没有过期，缓存的数据就一直有效。这种方案特别适合那些**读取高频、但修改极低频**的数据，最典型的场景就是用户的**权限信息（RBAC）**。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-5.png>)

在我的一个后台管理系统优化案例中，鉴权逻辑非常频繁，每次点击菜单、操作按钮都要查权限。但通过分析发现，用户的权限在一次登录会话期间几乎不会变化。

于是我们引入了会话级别缓存：

1. **缓存建立**：用户登录后，将其权限列表加载到会话缓存中（可以是服务端的 Session，也可以是 Redis 中的 Session 结构）。

2. **读取**：系统鉴权时优先从会话缓存中读取，只有不存在时才去调用权限模块。

3. **一致性维护**：为了保证安全性，我们监听了“用户权限修改”的消息队列。一旦管理员在后台修改了某人的权限，消费者直接强制清空该用户的会话缓存，迫使其下次操作时重新加载最新数据。

## **6. 去中心化——客户端缓存**

在微服务架构中，通常是服务端（Provider）负责缓存数据。但如果你发现调用某个微服务的网络开销很大，或者对数据一致性要求不那么高，你可以考虑将缓存前置到**调用方（客户端）**。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-6.png>)

思路很简单：比如服务 A 需要频繁调用服务 B 查询“商品详情”。服务 A 在拿到数据后，自己将其缓存在本地内存中，并设置一个较短的过期时间（例如 1 分钟）。下次再需要时，直接读本地，省去了一次微服务调用的网络开销。

**客户端缓存的独特优势：隔离性**

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-7.png>)

我们看上面这张图。如果大家公用服务端的 Redis 缓存，可能会出现“吵闹的邻居”现象：

* 服务B是个流量大户，疯狂写入数据。

* Redis 的 LRU 淘汰策略被触发。

* 结果把你服务 A 需要的热点数据给“挤”出去了。

* 服务 A 明明访问的是热数据，却总是无法命中缓存。

而如果服务 A 使用客户端缓存，数据存在自己的内存里，淘汰策略完全由自己掌控，再也不会受其他业务方影响。

**痛点与反范式设计：**

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-8.png>)

客户端缓存最大的痛点是**感知不到数据变更**。如上图所示，其他客户端修改了数据，服务端更新了，但当前客户端缓存里还是旧值。

为了解决这个问题，我们可以采用一&#x79CD;**“服务端依赖管理的客户端缓存”**&#x6A21;式。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-9.png>)

如上图（服务端依赖管理）：作为服务提供方（服务 B），我们可以封装一个包含缓存逻辑的 SDK（Jar 包）给调用方（服务 A）使用。

* 这个 SDK 内部包含了查询缓存、回源调用服务 B 的逻辑。

* 更高级的做法是，SDK 内部还可以订阅服务 B 的数据变更消息。当服务 B 数据变化时，发消息给 SDK，SDK 主动失效服务 A 本地的缓存。

* 这样既保留了客户端缓存的性能优势，又由服务端控制了逻辑的统一性。

## **7. 关联缓存预加载**

最后，我们来聊聊一种“未雨绸缪”的高级策略：**业务相关缓存预加载**。这需要我们对业务流程有深刻的洞察。通常，用户在执行操作 A 之后，大概率会紧接着执行操作 B。利用这个业务关联性，我们可以在处理 A 接口时，顺便把 B 接口需要的数据也加载到缓存中。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-10.png>)

比如在电商场景中，用户点击“**提交订单**”（接口 A，图中的“A接口”），那么他下一步大概率会进入“**收银台/支付页面**”（接口 B，图中的“B接口”）。

我们在处理“提交订单”接口时，除了完成订单创建逻辑，还可以异步地发起微服务调用，将该订单的**支付详情、优惠券信息、支付渠道配置**（图中的 Key2）等数据提前查询并放入缓存。 当用户真的跳转到“支付页面”调用接口 B 时，数据已经在缓存里等着了，用户会感觉页面跳转极其顺滑，系统响应极快。

当然，这种方案可能会造成一定的资源浪费（用户万一没支付呢？），所以通常建议设置较短的过期时间（比如 5 分钟），既利用了预加载的优势，又控制了资源消耗。

## **8. 缓存预热与流量灰度**

在系统发布或重启时，本地缓存是空的。如果立刻承接 100% 的流量，大量请求会瞬间击穿缓存回源数据库，导致性能剧烈抖动甚至宕机。为了解决这个问题，我们需要引入**缓存预热**。

预热有两种思路：

1. **启动加载**：在应用启动阶段（Startup Hook），主动加载配置类、字典类等热点数据。

2. **流量灰度（基于权重的预热）**：这是更平滑的做法。

![](<../../assets/img/后端进阶之路/面试场景题/缓存系统/面试官：只会 Redis？高并发下你的缓存架构怎么设计到极致？-11.png>)

如上图所示，我们可以利用负载均衡器的权重机制：

1. **冷启动阶段**（图示上方流程）：新节点刚启动时，将其权重调低（比如少量请求），只让它分配到少量流量。

2. **温热阶段**：随着运行时间的推移，少量的请求已经让本地缓存逐渐建立起来，节点开始“热”了。

3. **全量阶段**（图示下方流程）：通过自动化脚本或注册中心的心跳机制，逐步调高权重至 100%，承担正常流量。

这在面试中是一个非常好的结合点，因为它将缓存话题自然地引申到了**负载均衡策略**，体现了你的架构全局观。

## **9. 小结**

说到底，缓存从来不是“上个 Redis 就完事”的组件，而是一套围绕流量削峰、延迟优化与高可用兜底的系统工程。真正成熟的方案，一定是多级缓存协同、本地与远程互补、预热与降级并存，在一致性、性能与复杂度之间做取舍。不论是面试官想考的还是我们的真实业务场景，也从来不是某个 API，而是当流量暴涨或节点故障时，你能否用一整套架构思维稳住系统——把缓存当成体系去设计，系统才扛得住真实世界的高并发冲击。

<div style="background-color: #f0f9eb; padding: 10px 15px; border-radius: 4px; border-left: 5px solid #67c23a; margin: 20px 0; color:rgb(64, 147, 255);">

## <span style="color: #006400;">**学习交流**</span>
<span style="color:rgb(4, 4, 4);">
> 如果您觉得文章有帮助，可以关注下秀才的<strong style="color: red;">公众号：IT杨秀才</strong>，后续更多优质的文章都会在公众号第一时间发布，不一定会及时同步到网站。点个关注👇，优质内容不错过
</span>

![](../../assets/icon/avatar.png)

</div>
